<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Boid Mini Lab</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            min-height: 100vh;
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            display: flex;
            justify-content: center;
            align-items: flex-start;
            padding: 20px;
        }

        .container {
            background: white;
            border-radius: 20px;
            padding: 25px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            max-width: 900px;
            width: 100%;
        }

        h1 {
            text-align: center;
            color: #1a1a2e;
            margin-bottom: 5px;
            font-size: 1.8em;
        }

        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 20px;
            font-size: 0.9em;
        }

        .stats {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        .stat {
            background: #f0f4f8;
            padding: 8px 16px;
            border-radius: 8px;
            text-align: center;
        }

        .stat-label {
            font-size: 0.7em;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .stat-value {
            font-size: 1.2em;
            font-weight: 600;
            color: #0f3460;
        }

        #boidCanvas {
            display: block;
            margin: 0 auto 20px;
            border-radius: 12px;
            background: #0a0e27;
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .control-group {
            background: #f8f9fa;
            padding: 12px;
            border-radius: 10px;
        }

        .control-group label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            font-size: 0.85em;
            font-weight: 500;
            color: #333;
        }

        .control-group .value {
            color: #0f3460;
            font-weight: 600;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #ddd;
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: linear-gradient(135deg, #0f3460, #16213e);
            cursor: pointer;
            transition: transform 0.2s;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.2);
        }

        input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: linear-gradient(135deg, #0f3460, #16213e);
            cursor: pointer;
            border: none;
        }

        .presets {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        .preset-btn {
            padding: 10px 18px;
            font-family: 'Inter', sans-serif;
            font-size: 0.9em;
            font-weight: 500;
            border: 2px solid #0f3460;
            background: white;
            color: #0f3460;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .preset-btn:hover {
            background: #0f3460;
            color: white;
        }

        .preset-btn.active {
            background: #0f3460;
            color: white;
        }

        .buttons {
            display: flex;
            justify-content: center;
            gap: 10px;
            flex-wrap: wrap;
        }

        .btn {
            padding: 12px 24px;
            font-family: 'Inter', sans-serif;
            font-size: 0.95em;
            font-weight: 600;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-primary {
            background: linear-gradient(135deg, #0f3460, #16213e);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(15, 52, 96, 0.3);
        }

        .btn-secondary {
            background: #e9ecef;
            color: #333;
        }

        .btn-secondary:hover {
            background: #dee2e6;
        }

        .section-title {
            font-size: 0.75em;
            font-weight: 600;
            color: #999;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 10px;
            text-align: center;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Boid Mini Lab</h1>
        <p class="subtitle">Explore emergent flocking behavior with Craig Reynolds' boids algorithm</p>

        <div class="stats">
            <div class="stat">
                <div class="stat-label">Boids</div>
                <div class="stat-value" id="boidCount">100</div>
            </div>
            <div class="stat">
                <div class="stat-label">FPS</div>
                <div class="stat-value" id="fps">0</div>
            </div>
            <div class="stat">
                <div class="stat-label">Avg Speed</div>
                <div class="stat-value" id="avgSpeed">0</div>
            </div>
        </div>

        <canvas id="boidCanvas" width="850" height="400"></canvas>

        <p class="section-title">Presets</p>
        <div class="presets">
            <button class="preset-btn" onclick="applyPreset('schooling')">üêü Schooling</button>
            <button class="preset-btn active" onclick="applyPreset('flocking')">ü¶Ö Flocking</button>
            <button class="preset-btn" onclick="applyPreset('swarming')">üêù Swarming</button>
            <button class="preset-btn" onclick="applyPreset('chaotic')">üí´ Chaotic</button>
        </div>

        <p class="section-title">Parameters</p>
        <div class="controls">
            <div class="control-group">
                <label>
                    Number of Boids
                    <span class="value" id="numBoidsValue">100</span>
                </label>
                <input type="range" id="numBoids" min="10" max="300" value="100">
            </div>

            <div class="control-group">
                <label>
                    Separation
                    <span class="value" id="separationValue">1.5</span>
                </label>
                <input type="range" id="separation" min="0" max="3" value="1.5" step="0.1">
            </div>

            <div class="control-group">
                <label>
                    Alignment
                    <span class="value" id="alignmentValue">1.0</span>
                </label>
                <input type="range" id="alignment" min="0" max="3" value="1.0" step="0.1">
            </div>

            <div class="control-group">
                <label>
                    Cohesion
                    <span class="value" id="cohesionValue">1.0</span>
                </label>
                <input type="range" id="cohesion" min="0" max="3" value="1.0" step="0.1">
            </div>

            <div class="control-group">
                <label>
                    Max Speed
                    <span class="value" id="maxSpeedValue">4</span>
                </label>
                <input type="range" id="maxSpeed" min="1" max="10" value="4" step="0.5">
            </div>

            <div class="control-group">
                <label>
                    Max Force
                    <span class="value" id="maxForceValue">0.2</span>
                </label>
                <input type="range" id="maxForce" min="0.05" max="0.5" value="0.2" step="0.01">
            </div>

            <div class="control-group">
                <label>
                    Vision Radius
                    <span class="value" id="visionRadiusValue">50</span>
                </label>
                <input type="range" id="visionRadius" min="20" max="150" value="50">
            </div>

            <div class="control-group">
                <label>
                    Separation Radius
                    <span class="value" id="separationRadiusValue">25</span>
                </label>
                <input type="range" id="separationRadius" min="10" max="80" value="25">
            </div>
        </div>

        <div class="buttons">
            <button class="btn btn-primary" id="pauseBtn" onclick="togglePause()">Pause</button>
            <button class="btn btn-secondary" onclick="resetToDefaults()">Reset</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('boidCanvas');
        const ctx = canvas.getContext('2d');

        // Parameters
        const params = {
            numBoids: 100,
            separation: 1.5,
            alignment: 1.0,
            cohesion: 1.0,
            maxSpeed: 4,
            maxForce: 0.2,
            visionRadius: 50,
            separationRadius: 25
        };

        // Presets
        const presets = {
            schooling: {
                separation: 2.5,
                alignment: 1.5,
                cohesion: 1.0,
                maxSpeed: 3.5,
                maxForce: 0.2,
                visionRadius: 50,
                separationRadius: 25
            },
            flocking: {
                separation: 1.5,
                alignment: 1.0,
                cohesion: 1.0,
                maxSpeed: 4,
                maxForce: 0.2,
                visionRadius: 50,
                separationRadius: 25
            },
            swarming: {
                separation: 1.0,
                alignment: 0.5,
                cohesion: 2.0,
                maxSpeed: 5,
                maxForce: 0.2,
                visionRadius: 50,
                separationRadius: 25
            },
            chaotic: {
                separation: 0.3,
                alignment: 0.2,
                cohesion: 0.3,
                maxSpeed: 6,
                maxForce: 0.2,
                visionRadius: 50,
                separationRadius: 25
            }
        };

        let boids = [];
        let isPaused = false;
        let lastTime = performance.now();
        let frameCount = 0;
        let fps = 0;

        // Boid class
        class Boid {
            constructor() {
                this.x = Math.random() * canvas.width;
                this.y = Math.random() * canvas.height;
                const angle = Math.random() * Math.PI * 2;
                const speed = 2 + Math.random() * 2;
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;
                this.hue = 200 + Math.random() * 40;
            }

            distance(other) {
                return Math.sqrt((this.x - other.x) ** 2 + (this.y - other.y) ** 2);
            }

            separation(boids) {
                let steerX = 0, steerY = 0;
                let count = 0;

                for (let other of boids) {
                    const d = this.distance(other);
                    if (other !== this && d < params.separationRadius) {
                        let diffX = this.x - other.x;
                        let diffY = this.y - other.y;
                        const mag = Math.sqrt(diffX * diffX + diffY * diffY) || 1;
                        diffX /= mag;
                        diffY /= mag;
                        diffX /= d || 1;
                        diffY /= d || 1;
                        steerX += diffX;
                        steerY += diffY;
                        count++;
                    }
                }

                if (count > 0) {
                    steerX /= count;
                    steerY /= count;
                    const mag = Math.sqrt(steerX * steerX + steerY * steerY);
                    if (mag > 0) {
                        steerX = (steerX / mag) * params.maxSpeed - this.vx;
                        steerY = (steerY / mag) * params.maxSpeed - this.vy;
                        const steerMag = Math.sqrt(steerX * steerX + steerY * steerY);
                        if (steerMag > params.maxForce) {
                            steerX = (steerX / steerMag) * params.maxForce;
                            steerY = (steerY / steerMag) * params.maxForce;
                        }
                    }
                }

                return { x: steerX * params.separation, y: steerY * params.separation };
            }

            alignment(boids) {
                let avgVx = 0, avgVy = 0;
                let count = 0;

                for (let other of boids) {
                    const d = this.distance(other);
                    if (other !== this && d < params.visionRadius) {
                        avgVx += other.vx;
                        avgVy += other.vy;
                        count++;
                    }
                }

                if (count > 0) {
                    avgVx /= count;
                    avgVy /= count;
                    const mag = Math.sqrt(avgVx * avgVx + avgVy * avgVy);
                    if (mag > 0) {
                        avgVx = (avgVx / mag) * params.maxSpeed;
                        avgVy = (avgVy / mag) * params.maxSpeed;
                    }
                    let steerX = avgVx - this.vx;
                    let steerY = avgVy - this.vy;
                    const steerMag = Math.sqrt(steerX * steerX + steerY * steerY);
                    if (steerMag > params.maxForce) {
                        steerX = (steerX / steerMag) * params.maxForce;
                        steerY = (steerY / steerMag) * params.maxForce;
                    }
                    return { x: steerX * params.alignment, y: steerY * params.alignment };
                }

                return { x: 0, y: 0 };
            }

            cohesion(boids) {
                let avgX = 0, avgY = 0;
                let count = 0;

                for (let other of boids) {
                    const d = this.distance(other);
                    if (other !== this && d < params.visionRadius) {
                        avgX += other.x;
                        avgY += other.y;
                        count++;
                    }
                }

                if (count > 0) {
                    avgX /= count;
                    avgY /= count;
                    let desiredX = avgX - this.x;
                    let desiredY = avgY - this.y;
                    const mag = Math.sqrt(desiredX * desiredX + desiredY * desiredY);
                    if (mag > 0) {
                        desiredX = (desiredX / mag) * params.maxSpeed;
                        desiredY = (desiredY / mag) * params.maxSpeed;
                    }
                    let steerX = desiredX - this.vx;
                    let steerY = desiredY - this.vy;
                    const steerMag = Math.sqrt(steerX * steerX + steerY * steerY);
                    if (steerMag > params.maxForce) {
                        steerX = (steerX / steerMag) * params.maxForce;
                        steerY = (steerY / steerMag) * params.maxForce;
                    }
                    return { x: steerX * params.cohesion, y: steerY * params.cohesion };
                }

                return { x: 0, y: 0 };
            }

            update(boids) {
                const sep = this.separation(boids);
                const ali = this.alignment(boids);
                const coh = this.cohesion(boids);

                this.vx += sep.x + ali.x + coh.x;
                this.vy += sep.y + ali.y + coh.y;

                // Limit speed
                const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                if (speed > params.maxSpeed) {
                    this.vx = (this.vx / speed) * params.maxSpeed;
                    this.vy = (this.vy / speed) * params.maxSpeed;
                }

                this.x += this.vx;
                this.y += this.vy;

                // Edge wrapping
                if (this.x < 0) this.x = canvas.width;
                if (this.x > canvas.width) this.x = 0;
                if (this.y < 0) this.y = canvas.height;
                if (this.y > canvas.height) this.y = 0;
            }

            draw() {
                const angle = Math.atan2(this.vy, this.vx);
                const size = 8;

                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(angle);

                ctx.fillStyle = `hsl(${this.hue}, 70%, 60%)`;
                ctx.beginPath();
                ctx.moveTo(size, 0);
                ctx.lineTo(-size / 2, -size / 2);
                ctx.lineTo(-size / 2, size / 2);
                ctx.closePath();
                ctx.fill();

                ctx.restore();
            }

            getSpeed() {
                return Math.sqrt(this.vx * this.vx + this.vy * this.vy);
            }
        }

        // Initialize boids
        function initBoids() {
            boids = [];
            for (let i = 0; i < params.numBoids; i++) {
                boids.push(new Boid());
            }
        }

        // Adjust boid count
        function adjustBoidCount(newCount) {
            while (boids.length < newCount) {
                boids.push(new Boid());
            }
            while (boids.length > newCount) {
                boids.pop();
            }
        }

        // Animation loop
        function animate() {
            if (!isPaused) {
                // Motion trail effect
                ctx.fillStyle = 'rgba(10, 14, 39, 0.15)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                for (let boid of boids) {
                    boid.update(boids);
                    boid.draw();
                }

                // Calculate FPS
                frameCount++;
                const now = performance.now();
                if (now - lastTime >= 1000) {
                    fps = frameCount;
                    frameCount = 0;
                    lastTime = now;
                    document.getElementById('fps').textContent = fps;
                }

                // Calculate average speed
                let totalSpeed = 0;
                for (let boid of boids) {
                    totalSpeed += boid.getSpeed();
                }
                const avgSpeed = (totalSpeed / boids.length).toFixed(1);
                document.getElementById('avgSpeed').textContent = avgSpeed;
                document.getElementById('boidCount').textContent = boids.length;
            }

            requestAnimationFrame(animate);
        }

        // Toggle pause
        function togglePause() {
            isPaused = !isPaused;
            document.getElementById('pauseBtn').textContent = isPaused ? 'Resume' : 'Pause';
        }

        // Apply preset
        function applyPreset(name) {
            const preset = presets[name];
            if (!preset) return;

            // Update params
            Object.assign(params, preset);
            params.numBoids = 100;

            // Update sliders
            document.getElementById('numBoids').value = 100;
            document.getElementById('numBoidsValue').textContent = 100;
            document.getElementById('separation').value = preset.separation;
            document.getElementById('separationValue').textContent = preset.separation;
            document.getElementById('alignment').value = preset.alignment;
            document.getElementById('alignmentValue').textContent = preset.alignment;
            document.getElementById('cohesion').value = preset.cohesion;
            document.getElementById('cohesionValue').textContent = preset.cohesion;
            document.getElementById('maxSpeed').value = preset.maxSpeed;
            document.getElementById('maxSpeedValue').textContent = preset.maxSpeed;
            document.getElementById('maxForce').value = preset.maxForce;
            document.getElementById('maxForceValue').textContent = preset.maxForce;
            document.getElementById('visionRadius').value = preset.visionRadius;
            document.getElementById('visionRadiusValue').textContent = preset.visionRadius;
            document.getElementById('separationRadius').value = preset.separationRadius;
            document.getElementById('separationRadiusValue').textContent = preset.separationRadius;

            // Adjust boid count
            adjustBoidCount(100);

            // Update active button
            document.querySelectorAll('.preset-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
        }

        // Reset to defaults
        function resetToDefaults() {
            applyPreset('flocking');
        }

        // Setup controls
        function setupControls() {
            const controls = [
                { id: 'numBoids', param: 'numBoids', isInt: true, callback: adjustBoidCount },
                { id: 'separation', param: 'separation' },
                { id: 'alignment', param: 'alignment' },
                { id: 'cohesion', param: 'cohesion' },
                { id: 'maxSpeed', param: 'maxSpeed' },
                { id: 'maxForce', param: 'maxForce' },
                { id: 'visionRadius', param: 'visionRadius', isInt: true },
                { id: 'separationRadius', param: 'separationRadius', isInt: true }
            ];

            for (let ctrl of controls) {
                const slider = document.getElementById(ctrl.id);
                const valueDisplay = document.getElementById(ctrl.id + 'Value');

                slider.addEventListener('input', (e) => {
                    const value = ctrl.isInt ? parseInt(e.target.value) : parseFloat(e.target.value);
                    params[ctrl.param] = value;
                    valueDisplay.textContent = value;
                    if (ctrl.callback) {
                        ctrl.callback(value);
                    }
                });
            }
        }

        // Initialize
        initBoids();
        setupControls();
        animate();
    </script>
</body>
</html>
